<html>
<head>
	<style type="text/css">
		body	{
			color: #EEE;
			font-family: "Trebuchet MS";
			margin: 20 20 20 20;
		}

		.container	{
			padding: 10 10 10 10;
			background-color: rgba(255, 255, 255, 0.3);
			border: 1px solid;
			border-radius: 10px;
		}

		#puzzle	{
			/*border: 1px solid;*/
			border-color; #FFFFFF;
		}

	</style>

	<script src="priority-queue.js"></script>
	<script src="PuzzleNode.js"></script>

	<script type="text/javascript">

		// https://github.com/adamhooper/js-priority-queue


		/////////////// PUZZLE VARIABLES /////////////////
		var goalState = [1, 2, 3, 4, 5, 6, 7, 8, 0];

		/////////////// CANVAS VARIABLES /////////////////
		var sideLength, firstLine, secondLine, squareLength;





		//////////////////////////////////////////////////
		/////////////// PUZZLE FUNCTIONS /////////////////
		//////////////////////////////////////////////////
		function generator()
		{
			// implement Fisher-Yates Shuffle

		}

		function test(state)
		{
			for(var i = 0; i < goalState.length; i++)	{
				if(state[i] != goalState[i])	{
					return false;
				}
			}
			return true;
		}

		function solve(state)
		{
			var pq = new PriorityQueue({ comparator: function(a, b)	{ return a.priority - b.priority; }});
			// alert("asdf");
			var steps = 0;
			var initialState = state;

			var countInversions = inversionCount(initialState);

			// alert("countInversions = " + countInversions);

			console.log("\nNumber of inversions: " + countInversions);
			if(countInversions % 2 == 1)	{
				return "unsolvable";
			}
			// console.log("Asdf");

			var finalState = [];
			var prev = [];
			hInitial = getHammingDistanceWithSteps(initialState, steps);

			moves = 0;

			initialNode = new PuzzleNode(hInitial, steps, prev, initialState, null);

			// step 1:
			pq.queue(initialNode);
			// alert(steps)

			while(pq.length > 0)
			{
				moves++;
				// step 2:
				var curr = pq.dequeue();
				steps = curr.moves;
				// alert(steps)

				// step 3:
				if(test(curr.state))	{
					alert("GOOOOOOOAAAAALLLLLLLLLLL!");
					alert("steps = " + steps);
					alert("moves = " + moves);
					finalState = copylist(curr.state);
					finalNode = curr;
					break;
				}

				// step 4:
				var neighbors = getNeighborsOfState(curr.state);
				// for(var i = 0; i < neighbors.length; i++)	{
				// 	alert(neighbors[i])
				// }

				// step 5:
				steps++;

				// step 6:
				for(var i = 0; i < neighbors.length; i++)	{
					var nbr = neighbors[i];
					var h = getHammingDistanceWithSteps(nbr, steps);

					// Necessary optimization: don't enqueue if it's the same as the previous
					if(nbr == curr.prevState)	{
						console.log("nbr was the same as prevState, continuing...");
						continue;
					}

					var nbrNode = new PuzzleNode(h, steps, curr.state, nbr, curr);
					pq.queue(nbrNode);
				}
			}

			// step 8:
			if(finalState != [])	{
				return finalNode;
			}
			return "unsolvable";
		}

		/////////////// HELPER FUNCTIONS /////////////////

		function getNeighborsOfState(state)
		{
			var neighbors = [];

			// First find the location of the empty spot, O(n)
			var emptyIndex = 0;
			for(var i = 0; i < state.length; i++)	{
				if(state[i] == 0)	{
					emptyIndex = i;
					break;
				}
			}

			// emptyIndex should now equal the array index location of 0 in state in interval [0, 8]

			var inRow1 = (emptyIndex < 3);
			var inRow3 = (emptyIndex > 5);
			var inColumn1 = (emptyIndex % 3 == 0);
			var inColumn3 = ((emptyIndex + 1) % 3 == 0);

			// Case M(U)
			if(!inRow1)	{
				var caseMU = copylist(state);
				var swapIndex = (inRow3) ? (emptyIndex - 3) : (emptyIndex + 3);
				swap(caseMU, emptyIndex, swapIndex);
				neighbors.push(caseMU);
			}
			// Case M(D)
			if(!inRow3)	{
				var caseMD = copylist(state);
				var swapIndex = (inRow1) ? (emptyIndex + 3) : (emptyIndex - 3);
				swap(caseMD, emptyIndex, swapIndex);
				neighbors.push(caseMD);
			}
			// Case M(D)
			if(!inColumn1)	{
				var caseML = copylist(state);
				var swapIndex = (inColumn3) ? (emptyIndex - 1) : (emptyIndex + 1);
				swap(caseML, emptyIndex, swapIndex);
				neighbors.push(caseML);
			}
			// Case M(D)
			if(!inColumn3)	{
				var caseMR = copylist(state);
				var swapIndex = (inColumn1) ? (emptyIndex + 1) : (emptyIndex - 1);
				swap(caseMR, emptyIndex, swapIndex);
				neighbors.push(caseMR);
			}

			return neighbors;
		}

		function swap(array, i, j)
		{
			var temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}

		function getHammingDistanceWithSteps(state, steps)
		{
			return steps + getHammingDistanceWithoutNumberOfSteps(state);
		}

		function getHammingDistanceWithoutNumberOfSteps(state)
		{
			var hammingDistance = 0;
			for(var i = 0; i < state.length; i++)	{
				if(goalState[i] == 0)	{
					continue;
				}
				hammingDistance += ((state[i] != goalState[i]) ? 1 : 0);
			}
			return hammingDistance;
		}


		function getIndexDictionaryOfArray(array)
		{
			var dict = {};
			for(var i = 0; i < array.length; i++)	{
				dict[array[i]] = i;
			}
			return dict;
		}

		function inversionCount(array)
		{
			var count = 0;

			var map = getIndexDictionaryOfArray(goalState);

			for(var i = 0; i < array.length - 1; i++)	{
				if(array[i] == 0)	{
					continue;
				}
				for(var j = i + 1; j < array.length; j++)	{
					if(array[j] == 0)	{
						continue;
					}
					count += ((map[array[j]] < map[array[i]]) ? 1 : 0);
				}
			}

			return count;
		}

		function copylist(array)
		{
			return JSON.parse(JSON.stringify(array));
		}

		// function printGridFromState(state)
		// {
		// 	console.log("┌-------┐");
		// 	for(var i = 0; i < state.length; i++)	{
		// 		var value = (state[i] == 0) ? " " : state[i];
		// 		if(parseInt(i % 3) == 0)	{
		// 			console.log()
		// 		}
		// 	}
		// }


		//////////////////////////////////////////////////
		/////////////// CANVAS FUNCTIONS /////////////////
		//////////////////////////////////////////////////

		function drawSwap(c, value0, i0, j0, value1, i1, j1)
		{
			// cell (i0, j0) swaps with (i1, j1)
			drawSquare(c, value0, i1, j1);
			drawSquare(c, value1, i0, j0);
		}


		function drawSquare(c, value, i, j)
		{
			// alert("squareLength = " + squareLength + ", sideLength = " + sideLength)
			// alert("x = " + (squareLength * i) + ", y = " + (squareLength * j));
			// alert(c)
			// c.moveTo(0, 0);
			if(value == 0)	{
				c.fillStyle = "rgba(210, 210, 210, 5)";
				c.fillRect(squareLength * j + 1, squareLength * i + 1, squareLength - 2, squareLength - 2);
				return;
			}
			
			c.fillStyle = "rgba(0, 132, 255, 70)";
			c.fillRect(squareLength * j + 1, squareLength * i + 1, squareLength - 2, squareLength - 2);
			
			c.font = "32px Consolas";
			c.fillStyle = "rgba(0, 0, 0, 100)";
			c.fillText(value, squareLength * j + (squareLength / 2) - 10, squareLength * i + (squareLength / 2) + 10);
		}

		function drawNumberSquares(c, state)
		{
			for(var i = 0; i < state.length; i++)	{
				var row = parseInt(i / 3);
				var col = parseInt(i % 3);
				drawSquare(c, state[i], row, col);
			}
		}

		function drawGridLines(c)
		{
			// // Vertical lines
			// c.moveTo(100, 0);
			// c.lineTo(100, 300);
			// c.moveTo(200, 0);
			// c.lineTo(200, 300);

			// // Horizontal lines
			// c.moveTo(0, 100);
			// c.lineTo(300, 100);
			// c.moveTo(0, 200);
			// c.lineTo(300, 200);

			// alert("squareLength = " + squareLength + ", sideLength = " + sideLength)

			// 0, 1-99, 100, 101-199, 200, 201-299, 300


			// Vertical lines
			c.moveTo(0, 0);
			c.lineTo(0, sideLength);
			c.moveTo(squareLength, 0);
			c.lineTo(squareLength, sideLength);
			c.moveTo(squareLength * 2, 0);
			c.lineTo(squareLength * 2, sideLength);
			c.moveTo(sideLength, 0);
			c.lineTo(sideLength, sideLength);

			// Horizontal lines
			c.moveTo(0, 0);
			c.lineTo(sideLength, 0);
			c.moveTo(0, squareLength);
			c.lineTo(sideLength, squareLength);
			c.moveTo(0, squareLength * 2);
			c.lineTo(sideLength, squareLength * 2);
			c.moveTo(0, sideLength);
			c.lineTo(sideLength, sideLength);


			// Draw
			c.stroke();
		}

		function initializePuzzle(c)
		{
			drawGridLines(c);

			// initialState = [1, 2, 3, 8, 0, 4, 7, 6, 5];
			initialState = [7, 1, 0, 3, 4, 6, 2, 5, 8];
			// initialState = [1, 2, 3, 4, 5, 6, 7, 8, 0];
			// alert(test(initialState));
			// drawSquare(c, 3, 0, 2);
			// drawSquare(c, 0, 1, 1);
			drawNumberSquares(c, initialState);
			// drawSwap(c, 3, 0, 2, 4, 1, 2);

			return initialState;
		}

		function initializeGlobalCanvasVars(canvas)
		{
			sideLength = canvas.width;
			firstLine = (sideLength / 3) + 1;
			secondLine = firstLine + (sideLength / 3) + 1;
			squareLength = sideLength / 3;
		}

		window.onload = function()
		{
			// alert('test');
			var canvas = document.getElementById("puzzle");
			var c = canvas.getContext("2d");

			initializeGlobalCanvasVars(canvas);

			var startingState = initializePuzzle(c);

			solve(startingState);
		}
	</script>

</head>
<body bgcolor="#2b455e">
	
	<div class="container">
		<center>
			<h2>8-Puzzle Solver</h2>
		</center>
	</div>
	<div class="container">
		<center>
			<canvas id="puzzle" width="300" height="300">
				
			</canvas>
		<center>
	</div>
</body>
</html>

<!-- 

0, 1-99, 100, 101-199, 200, 201-299, 300

 -->